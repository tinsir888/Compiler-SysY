#include "Ast.h"
#include "SymbolTable.h"
#include "Unit.h"
#include "Instruction.h"
#include "IRBuilder.h"
#include <string>
#include "Type.h"

extern FILE *yyout;
int Node::counter = 0;
IRBuilder* Node::builder = nullptr;

int is_cond=-1;//用于判断一元表达式是否为条件 初始为-1


Node::Node()
{
    seq = counter++;
}
//将list中所有指令的跳转地址设置为bb 条件跳转就将为真情况跳到bb
void Node::backPatch(std::vector<Instruction*> &list, BasicBlock*bb)
{
    for(auto &inst:list)
    {
        if(inst->isCond())
            dynamic_cast<CondBrInstruction*>(inst)->setTrueBranch(bb);
        else if(inst->isUncond())
            dynamic_cast<UncondBrInstruction*>(inst)->setBranch(bb);
    }
}
//条件跳转将为假的情况跳转到bb
void Node::unbackPatch(std::vector<Instruction*> &list, BasicBlock*bb)
{
    for(auto &inst:list)
    {
        if(inst->isCond())
            dynamic_cast<CondBrInstruction*>(inst)->setFalseBranch(bb);
        else if(inst->isUncond())
            dynamic_cast<UncondBrInstruction*>(inst)->setBranch(bb);
    }
}


//将两个列表进行合并
std::vector<Instruction*> Node::merge(std::vector<Instruction*> &list1, std::vector<Instruction*> &list2)
{
    std::vector<Instruction*> res(list1);
    res.insert(res.end(), list2.begin(), list2.end());
    return res;
}








//-----------------------------------------生成中间代码---------------------

void Ast::genCode(Unit *unit)
{
    IRBuilder *builder = new IRBuilder(unit);
    Node::setIRBuilder(builder);
    root->genCode();
   
    fprintf(yyout,"declare void @putint(i32)\n");
    
    fprintf(yyout,"declare void @putch(i32)\n");
     fprintf(yyout,"declare i32 @getint() \n");
    fprintf(yyout,"declare i32 @getch()\n");
}

//可能有问题
void FunctionDef::genCode()
{
    
   // fprintf(stderr, "函数调用断点2\n");
   //fprintf(stderr, "  break 3\n");
    Unit *unit = builder->getUnit();
    Function *func = new Function(unit, se);
    
    //首先获得集合插入此函数
    BasicBlock *entry = func->getEntry();
    builder->setInsertBB(entry);
    if(this->params!=NULL)
    {
        //fprintf(stderr, "  break 3\n");
        params->genCode();//有问题
        //fprintf(stderr, "asadfadsf\n");
        /*for (std::vector<Type *>iterator it = params.begin(); it != params.end(); it ++){
            Instruction *alloca;
            Operand *addr;
            SymbolEntry *addr_se;
            Type *type;
            type = new PointerType(se -> getType());
            addr_se = new TemporarySymbolEntry (type, SymbolTable::getLabel());
            addr = new Operand(addr_se);
            alloca = new AllocaInstruction(addr, se);
            entry = 
        }*/
    }
   
    

    //这里一定要先生成函数体的中间代码 之后回填
    stmt->genCode();
    
     /**
     * Construct control flow graph. You need do set successors and predecessors for each basic block.
     * Todo
    */
    
     
//当函数体生成后 遍历当前函数所有块

for(std::vector<BasicBlock*>::iterator it=func->begin();it!=func->end();it++)
    {
        //int size=func->getBlockList().size();
        //fprintf(stderr, "   %d \n",size);
        //fprintf(stderr, "  break 1 %d \n",size);
       
        //每个块要遍历所有指令
        Instruction * ptr = (*it)->begin();
        while(ptr!=(*it)->end())
        {
            
            //fprintf(stderr, "  break 2\n");
            if(ptr->isCond())
            {
                BasicBlock * truebb = ((CondBrInstruction*) ptr)->getTrueBranch();
                BasicBlock * falsebb = ((CondBrInstruction*) ptr)->getFalseBranch();
                (*it)->addSucc(truebb); (*it)->addSucc(falsebb);
                truebb->addPred(*it); falsebb->addPred(*it);
            }
            else if(ptr->isUncond())
            {
                BasicBlock * next = ((UncondBrInstruction*) ptr)->getBranch();
                (*it)->addSucc(next);
                next->addPred(*it);
            }
           
            ptr = ptr->getNext();
        }
       // fprintf(stderr, "  break 3\n");
        
    }

   
    
}




void BinaryExpr::genCode()
{
    BasicBlock *bb = builder->getInsertBB();//当前插入位置
    Function *func = bb->getParent();//当前块存在的函数
    //block分割 用于处理跳转指令
    if (op == AND)
    {
        expr1->getOperand()->get_symbolentry()->setType(TypeSystem::boolType);
        expr2->getOperand()->get_symbolentry()->setType(TypeSystem::boolType);
        //以当前函数为主体 创建一个新块 表示新指令插入的地方
        BasicBlock *trueBB = new BasicBlock(func);  // if the result of lhs is true, jump to the trueBB.
        expr1->genCode();
        backPatch(expr1->trueList(), trueBB);//将expr1为真是跳转地址设置为trueBB
        //设置新的插入位置 新的指令会插入此位置
        builder->setInsertBB(trueBB);               // set the insert point to the trueBB so that intructions generated by expr2 will be inserted into it.
        expr2->genCode();
        true_list = expr2->trueList();
        false_list = merge(expr1->falseList(), expr2->falseList());
    }
    else if(op == OR)
    {
        // 针对或的回填
        expr1->getOperand()->get_symbolentry()->setType(TypeSystem::boolType);
        expr2->getOperand()->get_symbolentry()->setType(TypeSystem::boolType);
        BasicBlock *trueBB = new BasicBlock(func);  
        expr1->genCode();
        //第一个表达式如果为False 那么就跳转到第二个表达式
        unbackPatch(expr1->falseList(), trueBB);//即M.instr 也就是第二个表达式的所在的块
        builder->setInsertBB(trueBB);//第二个表达式设置新的插入位置               
        expr2->genCode();
        true_list = merge(expr1->trueList(), expr2->trueList());//或 二者之一为真即可跳转 所以要合并
        false_list = expr2->falseList();
    }
    //关系比较部分 不用跳转 直接插入当前块
    else if(op >= LESS && op <= GTR)
    {
       
        // Todo
        expr1->genCode();
        expr2->genCode();
        
        Operand *src1 =expr1->getOperand();
        Operand *src2 =expr2->getOperand();
        int opcode;//操作码 对应不同的大小关系

        switch (op)
        {
        case EQ:
            opcode= CmpInstruction::E;//比较指令中的对应数值
            
            break;
        case NEQ:
            opcode= CmpInstruction::NE;
       //      fprintf(stderr, "  break 1\n");
            break;
        case LESS:
            opcode= CmpInstruction::L;
        //    fprintf(stderr, "  break 2\n");
            break;
        case GTR:
            opcode= CmpInstruction::G;
            break;
        case LEQ:
            opcode= CmpInstruction::LE;
             
            break;
        case GEQ:
            opcode= CmpInstruction::GE;
            break;
        }
        //直接放到当前块即可 注意是比较指令
        new CmpInstruction(opcode, dst, src1, src2, bb);
        
        CondBrInstruction * condbr =  new CondBrInstruction(nullptr,nullptr,dst,bb);
        true_list.push_back(condbr);
        false_list.push_back(condbr);
       // fprintf(stderr, "  break 1\n");
      //  fprintf(stderr, "  break 2\n");
        JUDGE.is_cond=1;
    }
    //运算部分 同上
    else if(op >= ADD && op <= SUB)
    {
        expr1->genCode();
        expr2->genCode();
        Operand *src1 = expr1->getOperand();
        Operand *src2 = expr2->getOperand();
        int opcode;
        switch (op)
        {
        case ADD:
            opcode = BinaryInstruction::ADD;
            break;
        case SUB:
            opcode = BinaryInstruction::SUB;
            break;
        case MUL:
            opcode = BinaryInstruction::MUL;
            break;
        case DIV:
            opcode = BinaryInstruction::DIV;
            break;
         case REM:
            opcode = BinaryInstruction::REM;
       //      fprintf(stderr, "  break 3\n");
            break;   
        }
        new BinaryInstruction(opcode, dst, src1, src2, bb);
    }
    
}

//ok
void Constant::genCode()
{
    // we don't need to generate code.
}



void Id::genCode()
{
    
    Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getAddr();//获得当前地址
    //fprintf(stderr,"Operand *addr\n");
    SymbolEntry* addr_se;
    
    Function *func = builder->getInsertBB()->getParent();
    BasicBlock *entry = func->getEntry();

    IdentifierSymbolEntry *sp = dynamic_cast<IdentifierSymbolEntry *>(symbolEntry);//获得当前ID的表项
    //如果Id是函数的参数
    if(sp->getScope()==1)
    {
            BasicBlock *bb = builder->getInsertBB();
            if(sp->kput!=0)
            {
                //add beg
                SymbolEntry* tmp_se=getSymPtr();
                std::string name=tmp_se->toStr();
                //if(identifiers->lookup(name)==NULL)fprintf(stderr,"%s: not founded!!!\n", name.c_str());
                //else fprintf(stderr,"%s's identifiers: %s!\n",name.c_str(),identifiers->lookup(name)->toStr().c_str());
                //add end
                Type* type = sp->getType();
                addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
                addr = new Operand(addr_se);
                Instruction* alloca = new AllocaInstruction(addr, addr_se,nullptr,1);
                //
                //fprintf(stderr, "gen alloca ins. getlabel:%d\n",SymbolTable::getLabelnotInc()-1);
                //
                entry->insertFront(alloca); 
        
                addr->get_symbolentry()->setType(new PointerType(type));
                //add beg
                //dst=new Operand(tmp_se);
                //add end
                alloca = new StoreInstruction(addr, dst);
                //
                //fprintf(stderr, "gen store ins. getlabel:%d\n",SymbolTable::getLabelnotInc()-1);
                //fprintf(stderr, "dst is %s\n",dst->toStr().c_str());
                //
                entry->insertBack(alloca);
                sp->setAddr(addr);
                sp->kput=0;                
                //testtesttest
                //fprintf(stderr,"func params gen()!kput=%d\n",sp->kput);
            }
            addr_se = new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel());

            //fprintf(stderr, "gen load ins:getlabel:%d\n",SymbolTable::getLabelnotInc()-1);

            Operand *fack;
            fack = new Operand(addr_se);
            new LoadInstruction(fack, sp->getAddr(), bb);
            ////testtesttest
            //fprintf(stderr, " gen load inst \n");
            /////////////////////////////////
            this->dst=fack;
         
        }

    else
    {
        addr_se = new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel());
        Operand *fack;
        fack = new Operand(addr_se);
        BasicBlock *bb = builder->getInsertBB();
        addr = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getAddr();
        new LoadInstruction(fack, addr, bb);

        //fprintf(stderr, "gen load ins without alloca. getlabel:%d\n",SymbolTable::getLabelnotInc()-1);

        this->dst=fack;
    }
    
}

void IfStmt::genCode()
{
    Function *func;
    BasicBlock *then_bb, *end_bb;

    func = builder->getInsertBB()->getParent();
    then_bb = new BasicBlock(func);
    end_bb = new BasicBlock(func);

    BasicBlock *entry = func->getEntry();//找到头部块
    //设置前驱和后继
    then_bb->addPred(entry);
    entry->addSucc(then_bb);
    end_bb->addPred(then_bb);
    then_bb->addSucc(end_bb);
    
    //
    JUDGE.is_cond=0;
    cond->genCode();
   /* if(JUDGE.is_cond!=1)
    {
        BasicBlock *bb=builder->getInsertBB();
        fprintf(stderr, "  break 1\n");
        int opcode = CmpInstruction::NE;
        Operand* src1 = cond->getOperand();
        //Operand* src2 = src0_const0;
        SymbolEntry *integer = new ConstantSymbolEntry(TypeSystem::constType, 0);
        Operand *src2 =new Operand(integer);
        
        SymbolEntry * tse = new TemporarySymbolEntry(TypeSystem::boolType,SymbolTable::getLabel()); 
        Operand* dst = new Operand(tse);
        new CmpInstruction(opcode, dst, src1, src2, bb);
        
        Instruction* temp = new CondBrInstruction(nullptr,nullptr,dst,bb);
        cond->trueList().push_back(temp);
        cond->falseList().push_back(temp);
        
    }*/
   
   // 
   
    backPatch(cond->trueList(), then_bb);//条件为真 跳到then
    unbackPatch(cond->falseList(), end_bb);//条件为假  调到else

    builder->setInsertBB(then_bb);
    thenStmt->genCode();
    //设置then_bb的分支跳转块
    then_bb = builder->getInsertBB();
    new UncondBrInstruction(end_bb, then_bb);

    builder->setInsertBB(end_bb);
   //  fprintf(stderr, "  break 2\n");
   // fprintf(stderr, "  break 1\n");
  //  fprintf(stderr, "  break 1\n");
}

void IfElseStmt::genCode()
{
    // Todo
    Function *func;
    BasicBlock *then_bb, *end_bb,*else_bb;
     func = builder->getInsertBB()->getParent();
    then_bb = new BasicBlock(func);
    end_bb = new BasicBlock(func);
    else_bb= new BasicBlock(func);
    
     BasicBlock *entry = func->getEntry();
     //同样增加前驱后继
     then_bb->addPred(entry);
     entry->addSucc(then_bb);

    else_bb->addPred(then_bb);
    then_bb->addSucc(else_bb);

    end_bb->addPred(else_bb);
    else_bb->addSucc(end_bb);
     
    JUDGE.is_cond=0;
    cond->genCode();
    if(JUDGE.is_cond!=1)
    {
        BasicBlock *bb=builder->getInsertBB();
       // fprintf(stderr, "  break 1\n");
        int opcode = CmpInstruction::NE;
        cond->getSymPtr()->setType(TypeSystem::intType);
        Operand* src1 = new Operand(cond->getSymPtr());
        
        //Operand* src2 = src0_const0;
        SymbolEntry *integer = new ConstantSymbolEntry(TypeSystem::constType, 0);
        Operand *src2 =new Operand(integer);
        
        SymbolEntry * tse = new TemporarySymbolEntry(TypeSystem::boolType,SymbolTable::getLabel()); 
        Operand* dst = new Operand(tse);
        new CmpInstruction(opcode, dst, src1, src2, bb);
        
        Instruction* temp = new CondBrInstruction(nullptr,nullptr,dst,bb);
        cond->trueList().push_back(temp);
        cond->falseList().push_back(temp);
        
    }
    
    backPatch(cond->trueList(), then_bb);
    unbackPatch(cond->falseList(), else_bb);
    
    builder->setInsertBB(then_bb);
    thenStmt->genCode();
    then_bb = builder->getInsertBB();
    new UncondBrInstruction(end_bb, then_bb);//then直接跳到end
    
    builder->setInsertBB(else_bb);
    elseStmt->genCode();
    else_bb = builder->getInsertBB();
    new UncondBrInstruction(end_bb, else_bb);//else直接跳到end
     builder->setInsertBB(end_bb);
}

void CompoundStmt::genCode()
{
    // Todo
    if(stmt!=NULL)
    {
        stmt->genCode();
    }
}

void SeqNode::genCode()
{
    // Todo
    stmt1->genCode();
    if(stmt2!=NULL)
    { stmt2->genCode();
    }
    
}

void DeclStmt::genCode()
{
    //首先获取定义ID的表项
    //fprintf(stderr, "  break 1\n");
    IdentifierSymbolEntry *se = dynamic_cast<IdentifierSymbolEntry *>(id->getSymPtr());
    //判断全局变量和局部变量
    if(se->getScope()==0)
    {
       //fprintf(stderr, "  break 5\n");
        //fprintf(stderr, "  break 1\n");
        //针对全局变量 由于不在任何函数内部 额外在unit中添加一个结构存储 同时分配地址
        Operand *addr;
        SymbolEntry *addr_se;
        addr_se = new IdentifierSymbolEntry(*se);//需要新加一个构造函数
        addr_se->setType(new PointerType(se->getType()));//设置为指针类型 指向一个值
        addr = new Operand(addr_se);
        se->setAddr(addr);//存放变量地址信息
        
        //fprintf(stderr, "  break 2\n");
        //分配全局变量地址
        Instruction *alloca;
        
        //fprintf(stderr, "  break 3\n");
        alloca=new globalAllocaInstruction(addr,se);
        Unit *unit = builder->getUnit();
        //fprintf(stderr, "  break 4\n");
        unit->global_push(alloca);
        fprintf(stderr, "  break 5\n");
    }
    else if(se->getScope()>0)
    {
           
        //针对局部变量 要存放地址信息 设置类型 将分配内存指令块放入语句块 
        Function *func = builder->getInsertBB()->getParent();
        BasicBlock *entry = func->getEntry();//入口块 即头部
       
        //fprintf(stderr, "  break 1\n");
        
        Operand *addr;//地址操作数 
        SymbolEntry *addr_se;
        //test
        //fprintf(stderr, " addr_tostring:%s\n",addr->toStr());
        Type *type;
        
       
        
        type = new PointerType(se->getType());
        addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
        addr = new Operand(addr_se);
        
        
        
        //将分配指令 插入语句块
         Instruction *alloca;
         
         
         
         
        alloca = new AllocaInstruction(addr, se,builder->getInsertBB(),0);                   // allocate space for local id in function stack.
        entry->insertFront(alloca); // 分配指令要放在指令块的开头
        se->setAddr(addr);                                          // set the addr operand in symbol entry so that we can use it in subsequent code generation.
        
        //fprintf(stderr, "  break 3\n");
    }
}

void ReturnStmt::genCode()
{
    // Todo
    //有返回值就把返回语句插入当前块即可
    if(retValue1!=NULL)
    {
        
        retValue1->genCode();
        Operand *src =retValue1->getOperand();//获取返回值
        new RetInstruction(src, builder->getInsertBB());
        
    }
    else{
        new RetInstruction(nullptr, builder->getInsertBB());
    }
   
}

void AssignStmt::genCode()
{
    BasicBlock *bb = builder->getInsertBB();
    expr->genCode();
    //获取左值的地址和操作数放入存储指令
    Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(lval->getSymPtr())->getAddr();
    Operand *src = expr->getOperand();//获得要赋值的操作数
    /***
     * We haven't implemented array yet, the lval can only be ID. So we just store the result of the `expr` to the addr of the id.
     * If you want to implement array, you have to caculate the address first and then store the result into it.
     */
     //将赋值结果存入相应地址
    new StoreInstruction(addr, src, bb);
}


//-------------------------新加的
//一元运算符 额外定义一个指令
void UnaryExp::genCode()
{
    
    // Todo
    expr1->genCode();
    
    BasicBlock *bb = builder->getInsertBB();
   
    //Operand *src = new Operand(expr1->getSymPtr());//源操作数是符号后面的表达式
    Operand *src = expr1->getOperand();
    int opcode;
    switch (op)
        {
        case ADD://ADD要作为和0相加
            opcode = UnaryInstruction::ADD;
            break;
        case SUB://
            opcode = UnaryInstruction::SUB;
            break;
        case NOT://NOT要作为和1进行xor
            
            opcode = UnaryInstruction::NOT;
            break;
        }
    
    dst=new Operand(symbolEntry);//目标操作数为整体表达式 
    if(opcode==UnaryInstruction::NOT)
    {
        /*
        Function *func;
        BasicBlock *then_bb, *end_bb,*else_bb;
         func = builder->getInsertBB()->getParent();
        then_bb = new BasicBlock(func);
        end_bb = new BasicBlock(func);
        else_bb= new BasicBlock(func);
        
         BasicBlock *entry = func->getEntry();
         //同样增加前驱后继
         then_bb->addPred(entry);
         entry->addSucc(then_bb);

        else_bb->addPred(then_bb);
        then_bb->addSucc(else_bb);

        end_bb->addPred(else_bb);
        else_bb->addSucc(end_bb);
        
        
        //cond->genCode();
       // ExprNode* cond=new ExprNode(symbolEntry);
        {
            //和0比较
            int opcode1= CmpInstruction::NE;
            SymbolEntry *integer = new ConstantSymbolEntry(TypeSystem::constType, 0);
            Operand *src2 =new Operand(integer);
            new CmpInstruction(opcode1, dst, src, src2, bb);
            dst->get_symbolentry()->setType(TypeSystem::boolType);
            CondBrInstruction * condbr =  new CondBrInstruction(nullptr,nullptr,dst,bb);
            expr1->trueList().push_back(condbr);
            expr1->falseList().push_back(condbr);
            
            
            
        }
        
         backPatch(expr1->trueList(), then_bb);
        unbackPatch(expr1->falseList(), else_bb);
        
        builder->setInsertBB(then_bb);
        //then相当于 大于0时 则置为0 即给dst赋值为0
       // thenStmt->genCode();
       
        {
             Operand *addr = (expr1->getOperand());
             SymbolEntry *integer = new ConstantSymbolEntry(TypeSystem::constType, 0);
            Operand *src2 =new Operand(integer);
           new StoreInstruction(addr, src2, then_bb);
           
          //  SymbolEntry *se = new TemporarySymbolEntry(TypeSystem::intType, -1);
           // new AllocaInstruction(dst,se,then_bb,1);
            int opcode1= BinaryInstruction::ADD;
            SymbolEntry *integer = new ConstantSymbolEntry(TypeSystem::constType, 0);
            Operand *src1 =new Operand(integer);
            SymbolEntry *integer1 = new ConstantSymbolEntry(TypeSystem::constType, 0);
            Operand *src2 =new Operand(integer1);
            dst->get_symbolentry()->setType(TypeSystem::intType);
            new BinaryInstruction(opcode1, dst, src1, src2, then_bb);
            //找到当前数地址
           // fprintf(stderr, "  break 1\n");
            //Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(expr1->getSymPtr())->getAddr();
            //fprintf(stderr, "  break 2\n");
           
            //fprintf(stderr, "  break 3\n");
           // new StoreInstruction(dst, src2, then_bb);
        }
        
        
        then_bb = builder->getInsertBB();
        new UncondBrInstruction(end_bb, then_bb);//then直接跳到end
        
        builder->setInsertBB(else_bb);
        //else相当于小于0 则置为1
        //elseStmt->genCode();
        {
            //新的块要对dst先分配地址
         //    SymbolEntry *se = new TemporarySymbolEntry(TypeSystem::intType, -1);
         //   new AllocaInstruction(dst,se,else_bb,1);
             //找到当前数地址
            Operand *addr = (expr1->getOperand());
             SymbolEntry *integer = new ConstantSymbolEntry(TypeSystem::constType, 1);
            Operand *src2 =new Operand(integer);
           new StoreInstruction(addr, src2, else_bb);
           
          
            int opcode1= BinaryInstruction::ADD;
            SymbolEntry *integer1 = new ConstantSymbolEntry(TypeSystem::constType, 0);
            Operand *src1 =new Operand(integer1);
           dst->get_symbolentry()->setType(TypeSystem::intType);
            new BinaryInstruction(opcode1, dst, src1, src2, else_bb);
           
            
            
            
        }
        else_bb = builder->getInsertBB();
        new UncondBrInstruction(end_bb, else_bb);//else直接跳到end
        builder->setInsertBB(end_bb);
        
        
        JUDGE.is_cond=1;*/
        
        
        
        int opcode1= BinaryInstruction::MUL;
         SymbolEntry *integer1 = new ConstantSymbolEntry(TypeSystem::constType, -1);
            Operand *src1 =new Operand(integer1);
           dst->get_symbolentry()->setType(TypeSystem::intType);
            new BinaryInstruction(opcode1, dst, dst, src1, bb);
        
        return;
    }
    
    //添加的一元表达式 将新的值返回给表达式
    new UnaryInstruction(opcode, dst, src, bb);
     
    
    
    
}

void ConstId::genCode()
{
    // Todo 参照Id 即从目标地址加载值到目的操作数
    BasicBlock *bb = builder->getInsertBB();
    Operand *addr = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getAddr();
    //当前consid的值存放在dst中
    new LoadInstruction(dst, addr, bb);
}

/*void AssignExp::genCode()
{
    // Todo
}*/

void FuncCallExp::genCode()
{
    // Todo
    //函数调用设计为类似于跳转的指令
    //获取当前函数的表项 用于构建跳转的地址
    IdentifierSymbolEntry *goto_ = dynamic_cast<IdentifierSymbolEntry *>(this->st);
    
    BasicBlock *bb;
    Operand *addr,*goto_op;//addr为当前 地址 
    SymbolEntry *addr_se;
    addr_se = new TemporarySymbolEntry(TypeSystem::intType, SymbolTable::getLabel());//获取当前位置
    addr = new Operand(addr_se);
    goto_op=new Operand(goto_);
    bb= builder->getInsertBB();
    //
    callparamsType.reset();//每次生成函数调用中间代码先初始化重置参数向量
    
    //fprintf(stderr, "  break 1\n");
    //分别对有参数和没有参数进行判断
    if(params!=NULL)//有参数就要都遍历 并且参数也要放入指令
    {
        std::vector<Operand *> temp;
        params->genCode();
        
         //接下来遍历参数 因为要从右到左入栈 所以这里要反向遍历
        std::vector<Operand*> para=callparamsType.get();//获取调用函数向量
        std::vector<Operand*> final_para;
        for( std::vector<Operand*>::reverse_iterator revit=para.rbegin();
        revit!=para.rend();revit++)
        {
            final_para.push_back(*revit);
            
        }
         new FunCcallInstruction(addr,goto_op,bb,final_para);
        this->dst=addr;
    }
    else
    {//没有参数 直接生成指令
        
        new FunCcallInstruction(addr,goto_op,bb);
        this->dst=addr;
       
    }

}

void ADDstmt::genCode()
{
    // Todo
    expr->genCode();
}


void ConstDecAndAssStmt::genCode()
{
    // Todo
    id->genCode();
    expr->genCode();
}

void VA::genCode()
{
    // Todo
    if(id!=NULL)
    {
        id->genCode();
    }
    if(ass!=NULL)
    {
        ass->genCode();
    }
}
void VAs::genCode()
{
    // Todo
    va1->genCode();
    if(va2!=NULL)
    {
         va2->genCode();
    }
}
void MVA::genCode()
{
    // Todo
    if(id!=NULL)
    {
         id->genCode();
        
    }
    if(ass!=NULL)
    {
        ass->genCode();
    }
}
void MVAs::genCode()
{
    // Todo
    va1->genCode();
    if(va2!=NULL)
    {
         va2->genCode();
    }
}


void MULdecstmt::genCode()
{
    // Todo
    vas1->genCode();
    vas2->genCode();
}
void MULconstdecstmt::genCode()
{
    // Todo
    vas1->genCode();
    vas2->genCode();
}
//while语句类似于if
void Whilestmt::genCode()
{
    // Todo
   // fprintf(stderr, "  break 1\n");
    Function * func;
    BasicBlock *Condbb, * Blockbb, *end_bb,*insertbb;
    func = builder->getInsertBB()->getParent();
    Condbb = new BasicBlock(func);
    Blockbb = new BasicBlock(func);
    end_bb = new BasicBlock(func);
    
    BasicBlock *entry = func->getEntry();//找到头部块
    //如何添加前驱后继？ block后可能是cond 也可能是end
    Condbb->addPred(entry);
    entry->addSucc(Condbb);
     
     
    Condbb->addSucc(Blockbb);
    Condbb->addSucc(end_bb);
    Blockbb->addSucc(end_bb);
    
    
    Blockbb->addPred(Condbb);
    end_bb->addPred(Condbb);
    end_bb->addPred(Blockbb);
     
     
    Instruction* inlla;
    //首先要跳转到cond语句块生成代码
    inlla=new UncondBrInstruction(Condbb); 
    insertbb=builder->getInsertBB();//获取当前插入块 
    insertbb->insertBack(inlla);//当前块要跳转到cond执行 这里就放到当前指令链表的尾部
    
    //cond指令要插入到Cond语句块
    builder->setInsertBB(Condbb);
    
    is_cond=1;
    Cond->genCode();
    is_cond=-1;


    backPatch(Cond->trueList(),Blockbb);//cond为真 去执行函数体
    unbackPatch(Cond->falseList(),end_bb);//cond为假 直接结束

    //循环体指令插入到循环体块
    builder->setInsertBB(Blockbb);
    stmt->genCode();
    
    //循环体执行结束之后要再次跳转到cond语句块 
    insertbb = builder->getInsertBB();//生成代码的时候可能更改插入块 要再次获取
    inlla=new UncondBrInstruction(Condbb);
    insertbb->insertBack(inlla);//当前块要跳转到cond执行 这里就放到当前指令链表的尾部

    builder->setInsertBB(end_bb);
    

}
void Params::genCode()
{
    // Todo
    //fprintf(stderr, " Params::gencode()\n");
    exp1->genCode();//有问题
    //add by dyt
    //Operand *src =exp1->getOperand();//获取返回值
    //new AllocaInstruction(src, builder->getInsertBB());
    //dyt add end
    //fprintf(stderr, "exp1->gencode() finished!\n");
//    fprintf(stderr, "  break 2\n");
    if(exp2!=NULL)
    {
        
        exp2->genCode();
        //fprintf(stderr, "multiple params\n");
    }
   // fprintf(stderr, "  break 3\n");
}

void Param::genCode()
{
    // Todo
    //fprintf(stderr, "  param::gencode()\n");
    SymbolEntry *addr_se;
    //fprintf(stderr, "  break 2\n"); 
    id->genCode();//这里有问题
    //fprintf(stderr,"param's id:%s\n",id->dst->toStr().c_str());
    if(expr1!=NULL)
    {
        //expr1->genCode();
        //BasicBlock * entry = func->getEntry();//dyt add
        IdentifierSymbolEntry* se=static_cast<IdentifierSymbolEntry*>(id->getSymPtr());

        //dyt add beg
        Unit *unit = builder->getUnit();
        Function *func = new Function(unit, se);
        BasicBlock *entry = func->getEntry();
        Type *type = new PointerType(se->getType());
        addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
        Operand *addr = new Operand(addr_se);
        Instruction *alloca = new AllocaInstruction(addr, se);
        entry->insertFront(alloca);
        se->setAddr(addr);
        Operand *ope=expr1->getOperand();
        //func->op(function's menber).push_back(ope);
        BasicBlock *bb=builder->getInsertBB();
        new StoreInstruction(addr, ope, bb);
        //fprintf(stderr, "storeins(adddr, ope, bb)gen!\n");
        //dyt add end

      /*addr_se = new IdentifierSymbolEntry(*se);
      addr_se->setType(new PointerType(se->getType()));
      Operand* addr;
      addr = new Operand(addr_se);*/


      /*se->setAddr(addr);
      this->symbolEntry=se;
      this->dst=addr;*/
    }
}

//调用时的参数 注意要放入调用队列中
void Paramlist::genCode()
{
    // Todo
    exp1->genCode();
    this->dst=exp1->getOperand();
    callparamsType.push(this->dst);
    if(exp2!=NULL)
    {
        exp2->genCode();
        this->dst=exp2->getOperand();
        callparamsType.push(this->dst);
    }
}

//多余定义 不用写
void FuncCall::genCode()
{
    // Todo
}

void Emptystmt::genCode()
{
    // Todo
}

//
void DAssignStmt::genCode()
{
    // Todo
    //首先是定义部分 要将id对应的表现设置类型 地址 或者是分配空间
    IdentifierSymbolEntry *se = dynamic_cast<IdentifierSymbolEntry *>(id->getSymPtr());
    //判断全局变量和局部变量
    if(se->getScope()==0)
    {
        //针对全局变量 由于不在任何函数内部 额外在unit中添加一个结构存储 同时分配地址
        Unit *unit = builder->getUnit();
        Operand *addr;
        Instruction *alloca;
        SymbolEntry *addr_se;
        addr_se = new IdentifierSymbolEntry(*se);
        addr_se->setType(new PointerType(se->getType()));
        addr = new Operand(addr_se);
        se->setAddr(addr);//存放变量地址信息
        
        //分配全局变量地址
        alloca=new globalAllocaInstruction(dst,se,expr->getOperand());
       
        unit->global_push(alloca);
    }
    //
    //else if(se->getScope()>=2)
    else if(se->getScope()>=1)
    { //针对局部变量 要存放地址信息 设置类型 将分配内存指令块放入语句块 
        Function *func = builder->getInsertBB()->getParent();
        BasicBlock *entry = func->getEntry();//入口块 即头部
        Instruction *alloca;
        Operand *addr;
        SymbolEntry *addr_se;
        Type *type;
        type = new PointerType(se->getType());
        addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
        addr = new Operand(addr_se);
        alloca = new AllocaInstruction(addr, se);                   
        entry->insertFront(alloca);                                 
        se->setAddr(addr);
        
        expr->genCode();
        BasicBlock *bb = builder->getInsertBB();
    
        Operand *adpr = se->getAddr();
        Operand *src = expr->getOperand();
        new StoreInstruction(adpr, src, bb);          
                                 
    }
    
    
    
}


void ConstDeclstmt::genCode()
{
    // Todo
    
    if(expr!=NULL)
    {
        expr->genCode();
    }
}
//已废
void Funcname::genCode()
{
    // Todo
}



void Idlist::genCode()
{
    // Todo
     expr1->genCode();
    expr2->genCode();
}
void VarDeclstmt::genCode()
{
    // Todo
    expr1->genCode();
}
void Decvar::genCode()
{
    // Todo
     IdentifierSymbolEntry *se = dynamic_cast<IdentifierSymbolEntry *>(id->getSymPtr());
    //id表项 没有kind 用scope来区分
    if(se->getScope()==0)
    {
        //fprintf(stderr, "定义断点1 \n");
        Unit *unit = builder->getUnit();
        Operand *addr;
        SymbolEntry *addr_se;
        Instruction *alloca;
        addr_se = new IdentifierSymbolEntry(*se);
        addr_se->setType(new PointerType(se->getType()));
        addr = new Operand(addr_se);
        //fprintf(stderr, "定义断点2 \n");
        se->setAddr(addr);
        //fprintf(stderr, "定义断点4 \n");
        alloca=new globalAllocaInstruction(dst,se);//有问题
        
        unit->global_push(alloca);
        //fprintf(stderr, "定义断点4 \n");
    }
    else //处理函数内部的变量
    {if(se->getScope()>1)
    {
        //fprintf(stderr, "定义断点4 \n");
        Function *func = builder->getInsertBB()->getParent();
        BasicBlock *entry = func->getEntry();
        Instruction *alloca;
        Operand *addr;
        SymbolEntry *addr_se;
        Type *type;
        type = new PointerType(se->getType());
        addr_se = new TemporarySymbolEntry(type, SymbolTable::getLabel());
        addr = new Operand(addr_se);
        alloca = new AllocaInstruction(addr, se,NULL,0);
        this->dst=addr;                   // allocate space for local id in function stack.
        entry->insertFront(alloca);                                 // allocate instructions should be inserted into the begin of the entry block.
        se->setAddr(addr);                                          // set the addr operand in symbol entry so that we can use it in subsequent code generation.
       // fprintf(stderr, "定义断点5 \n");
    }
    else{//处理函数参数列表
    //fprintf(stderr, "定义断点5  %d\n",se->getScope());
        Operand *addr;
        SymbolEntry *addr_se;
        addr_se = new IdentifierSymbolEntry(*se);
        addr_se->setType(new PointerType(se->getType()));
        addr = new Operand(addr_se);
        se->setAddr(addr);
    }
    }
}

void PutInchars::genCode()
{
    // Todo
     this->dst=new Operand(this->symbolEntry);
}
void putsFunc::genCode()
{
    expr1->genCode();
    expr2->genCode();
    if(expr3)
       expr3->genCode();
}


//---------------------------------------------------类型检查-----------



void Ast::typeCheck()
{
    if(root != nullptr)
        root->typeCheck();
}

//ok
void FunctionDef::typeCheck()
{
    // Todo
    //如果函数定义 返回类型不为空 也不为INT报错
   // fprintf(stderr, "函数定义断点1 \n");
    std::string name=se->toStr();
   // fprintf(stderr, "函数定义断点2 \n");
  // fprintf(stderr, "函数调用断点1\n");
  
  
  
    if(se->getType()->isFunc()!=1 
    )
    {
         fprintf(stderr,"函数 %s 返回类型不支持",name.c_str());
    }
    
    if(params!=NULL)
    {
        //fprintf(stderr, "break 6 \n");
        params->typeCheck();
        //fprintf(stderr, "break 7 \n");
    }
    //对函数体进行检查
    stmt->typeCheck();
    
   // fprintf(stderr, "函数调用断点2\n");
    //fprintf(stderr, "函数定义断点3 \n");
    /*
    if(identifiers->lookup(name)==nullptr)
    {
        fprintf(stderr,"函数 %s 重定义",name.c_str());
        exit(EXIT_FAILURE);
    }
    */
    
}

//ok
void ConstDeclstmt::typeCheck()
{
    // Todo
    expr->typeCheck();
    
}
//ok
void BinaryExpr::typeCheck()
{
    // Todo
    Type *type1 = expr1->getSymPtr()->getType();
    Type *type2 = expr2->getSymPtr()->getType();
    if(
    (type2->toStr()=="void()" || type1->toStr()=="void()")
    )
    {
         fprintf(stderr, "type %s 为空 不能赋值",
            type1->toStr().c_str());
            exit(EXIT_FAILURE);
            return;
        
    }
    if(type1 != type2)
    {
        if(
        !(
        
        (type2->toStr()=="constant" && type1->toStr()=="i32")
        ||(type1->toStr()=="constant" && type2->toStr()=="i32")
        
        || (type1->toStr()=="i32" && type2->toStr()=="constant")
        || (type1->toStr()=="constant" && type2->toStr()=="i32")
        
        || (type1->toStr()=="i1" && type2->toStr()=="constant")
        || (type1->toStr()=="constant" && type2->toStr()=="i1")
        
        || (type1->toStr()=="i32" && type2->toStr()=="i1")
        || (type1->toStr()=="i1" && type2->toStr()=="i32")
        
        || (type1->toStr()=="i32()" && type2->toStr()=="i32")
        || (type1->toStr()=="i32" && type2->toStr()=="i32()")
        
        || (type1->toStr()=="i32()" && type2->toStr()=="i32()")
        
        || (type1->toStr()=="i32()" && type2->toStr()=="i1")
        || (type1->toStr()=="i1" && type2->toStr()=="i32()")

        //||(type1->toStr()=="i32" && type2->toStr()=="i32")
        )
        )
        {
            fprintf(stderr, "type %s and %s mismatch in line xx\n",
            type1->toStr().c_str(), type2->toStr().c_str());
            exit(EXIT_FAILURE);
            return;
        }
    }
    symbolEntry->setType(type1);
    expr1->typeCheck();
    expr2->typeCheck();
    
}

//ok
//常量检查 即判断是否为常量类型
void Constant::typeCheck()
{
    // Todo
    if(symbolEntry->getType()!=TypeSystem::constType)
    {
        fprintf(stderr, "常量类型没有设置为constant");
        exit(EXIT_FAILURE);
        return;
    }
}

//ok
void Id::typeCheck()
{
    // Todo
    SymbolEntry* se=getSymPtr();
    std::string name=se->toStr();
    //然后判断是否有定义过
    /*if(identifiers->lookup(name)==NULL)
    {
        fprintf(stderr,"%s 没有定义",name.c_str());
        exit(EXIT_FAILURE);
        return;
    }*/
}

//ok
void IfStmt::typeCheck()//把cond的类型设置为bool
{
    // Todo
    //1判断cond的类型 必须要是INT的
    cond->typeCheck();
    if(cond->getSymPtr()->getType()->isInt()==1
|| cond->getSymPtr()->getType()->isConst()==1
 
)
    
    {
        cond->getSymPtr()->setType(TypeSystem::boolType);
    }
    else{
        
        if(cond->getSymPtr()->getType()->isFunc()==1)
        {
            FunctionType* temp=static_cast<FunctionType*>(cond->getSymPtr()->getType());
            Type*tmp=temp->getRetType();
            if(tmp->isInt()==1
|| tmp->isConst()==1
            
            )
            {
                cond->getSymPtr()->setType(TypeSystem::boolType);
                thenStmt->typeCheck();
                return;
            }
        }
        fprintf(stderr,"if语句条件类型不正确\n");
        exit(EXIT_FAILURE);
        return;
    }
    //同时对then语句进行类型检查
    //fprintf(stderr,"if语句断点1\n");
    thenStmt->typeCheck();
    //fprintf(stderr,"if语句断点2\n");
}

//ok
void IfElseStmt::typeCheck()//把cond的类型设置为bool
{
    // Todo
    cond->typeCheck();
    if(cond->getSymPtr()->getType()->isInt()==1
    || cond->getSymPtr()->getType()->isConst()==1)
    {
        cond->getSymPtr()->setType(TypeSystem::boolType);
    }
    else{
        if(cond->getSymPtr()->getType()->isFunc()==1)
        {
            FunctionType* temp=static_cast<FunctionType*>(cond->getSymPtr()->getType());
            Type*tmp=temp->getRetType();
            if(tmp->isInt()==1
|| tmp->isConst()==1
            
            )
            {
                cond->getSymPtr()->setType(TypeSystem::boolType);
                thenStmt->typeCheck();
                elseStmt->typeCheck();
                return;
            }
        }
        fprintf(stderr,"ifelse语句条件类型不正确\n");
        exit(EXIT_FAILURE);
        return;
    }
    thenStmt->typeCheck();
    elseStmt->typeCheck();
}

//ok
void CompoundStmt::typeCheck()
{
    // Todo
    if(stmt!=NULL)
    {stmt->typeCheck();
    }
}

//ok
void SeqNode::typeCheck()
{
    // Todo
    stmt1->typeCheck();
     if(stmt2!=NULL)
    { stmt2->typeCheck();
    }
   
}

//ok
//变量重复声明的情况：
void DeclStmt::typeCheck()
{
    // Todo
    Type *type1=id->getSymPtr()->getType();
    //首先判断是否为整型
    if(type1->isInt()!=1)
    {
        fprintf(stderr,"定义中 type %s 不匹配 in line xx",
        type1->toStr().c_str());
        exit(EXIT_FAILURE);
        return;
    }
    SymbolEntry *se=id->getSymPtr();
    std::string name=se->toStr();
    
    //然后判断是否重定义
    /*if(identifiers->search_inthis(name)!=NULL)
    {
        fprintf(stderr,"%s 重定义",name.c_str());
        exit(EXIT_FAILURE);
        return;
    }*/
    
}

//ok
//检查函数返回值是否和定义时相同 语法分析实现
void ReturnStmt::typeCheck()
{
    // Todo
    //SymbolTable* last_table=identifiers->getPrev();
    //先找到最近的一个函数的符号表项：
    
    if(retValue1!=NULL)
    {
        //获得expr的type
        retValue1->typeCheck();
        std::string ret_type=retValue1->getSymPtr()->getType()->toStr();
        // fprintf(stderr," return返回类型:%s \n",ret_type.c_str());
        //Type* retType=retValue1->getSymPtr()->getType();
        //获得最近函数的符号表项
        SymbolEntry* se=identifiers->search_func();
        std::string funcrt=se->getType()->toStr();
       // fprintf(stderr," 函数返回类型:%s \n",funcrt.c_str());
        if(ret_type=="void()" && se->getType()->isVoid()!=1)
        {
             fprintf(stderr," 函数返回void 类型不一致 \n");
            return;
            
        }
        
    }
   
    //获得最近函数的符号表项
    SymbolEntry* se=identifiers->search_func();
    std::string funcrt=se->getType()->toStr();
    /*
    fprintf(stderr,"函数返回类型：%s ",funcrt.c_str());
    if(funcrt!="void()")
    {
        if(rt==0)
        {
            fprintf(stderr," 函数返回类型不一致");
            return;
        }
        
    }
    else{
        if(rt==1)
        {
            fprintf(stderr," 函数返回类型不一致");
            return;
        }
    }
    */
}

void FuncCallExp::typeCheck()
{
    // Todo
   
    Type * tmp=st->getType();
   FunctionType* temp=static_cast<FunctionType*>(tmp);
   
    symbolEntry->setType(temp->getRetType());
    
}

//ok
void AssignStmt::typeCheck()
{
    // Todo
    lval->typeCheck();
     Type *type1=lval->getSymPtr()->getType();
     expr->typeCheck();
    Type *type2=expr->getSymPtr()->getType();
    if(type1 != type2)
    {
        if(!
       ( (type2->toStr()=="constant" && type1->toStr()=="i32")||
        (type2->toStr()=="i32" && type1->toStr()=="constant")||
        
        (type2->toStr()=="i32()" && type1->toStr()=="i32")||
        (type2->toStr()=="i32" && type1->toStr()=="i32()")||
        
        (type2->toStr()=="i32()" && type1->toStr()=="constant")||
        (type2->toStr()=="constant" && type1->toStr()=="i32()")||
        
        (type2->toStr()=="i32" && type1->toStr()=="i1")||
        (type2->toStr()=="i1" && type1->toStr()=="i32")||
        
        (type2->toStr()=="i32()" && type1->toStr()=="i1")||
        (type2->toStr()=="i1" && type1->toStr()=="i32()")||
        
        (type2->toStr()=="constant" && type1->toStr()=="i1")||
        (type2->toStr()=="i1" && type1->toStr()=="constant")
        
       
        
              
        )
        )
        {
            fprintf(stderr, "赋值语句中 type %s and %s 不匹配 xx",
            type1->toStr().c_str(), type2->toStr().c_str());
            exit(EXIT_FAILURE);
            return;
        }
    }
   
}

//---------------------------------------新加的------------------
//ok
void UnaryExp::typeCheck()
{
    // Todo
    expr1->typeCheck();
    //设置本表达式的类型
    Type *type1 = expr1->getSymPtr()->getType();
    symbolEntry->setType(type1);
}

//ok
void ConstId::typeCheck()
{
    // Todo
    SymbolEntry* se=getSymPtr();
    std::string name=se->toStr();
    //然后判断是否有定义过
    /*if(identifiers->lookup(name)==nullptr)
    {
        fprintf(stderr,"%s 没有定义",name.c_str());
        exit(EXIT_FAILURE);
        return;
    }*/
}

//ok
/*void AssignExp::typeCheck()
{
    // Todo
    Type *type1 = lval->getSymPtr()->getType();
    Type *type2 = expr->getSymPtr()->getType();
    if(type1 != type2)
    {
        fprintf(stderr, "赋值表达式中 type %s and %s 不匹配in line xx",
        type1->toStr().c_str(), type2->toStr().c_str());
        exit(EXIT_FAILURE);
        return;
    }
    symbolEntry->setType(type1);
}
*/


//ok
void ADDstmt::typeCheck()
{
    // Todo
    expr->typeCheck();
}

//ok
void ConstDecAndAssStmt::typeCheck()
{
    // Todo
    //---------------------------------------第一部分检查定义是否类型有误
    Type *type1=id->getSymPtr()->getType();
    //首先判断是否为整型
    if(type1->isInt()!=1)
    {
        fprintf(stderr,"常量定义中 type %s 不匹配 in line xx",
        type1->toStr().c_str());
        exit(EXIT_FAILURE);
        return;
    }
    SymbolEntry *se=id->getSymPtr();
    std::string name=se->toStr();
    //然后判断是否重定义
    /*if(identifiers->search_inthis(name)!=nullptr)
    {
        fprintf(stderr,"常量%s 重定义",name.c_str());
        exit(EXIT_FAILURE);
        return;
    }*/
    //---------------------------------------第二部分检查赋值是否类型有误
    //首先对表达式进行类型检查
    expr->typeCheck();
    //然后判断表达式的类型
    Type *type2=expr->getSymPtr()->getType();
    if(type1!=type2)
    {
        fprintf(stderr,"常量%s 赋值类型错误",name.c_str());
        exit(EXIT_FAILURE);
        return;
    }
}

//ok
//常量 判断是否为常量
void VA::typeCheck()
{
    // Todo
    if (id!=NULL)
    {
         Type *type1=id->getSymPtr()->getType();
        //首先判断是否为整型
        if(type1->isInt()!=1)
        {
            fprintf(stderr,"常量定义中 type %s 不匹配 in line xx",
            type1->toStr().c_str());
            exit(EXIT_FAILURE);
            return;
        }
        SymbolEntry *se=id->getSymPtr();
        std::string name=se->toStr();
        //然后判断是否重定义
       /* if(identifiers->search_inthis(name)!=nullptr)
        {
            fprintf(stderr,"常量%s 重定义",name.c_str());
            exit(EXIT_FAILURE);
            return;
        }*/
    }
    if(ass!=NULL)
    {
        ass->typeCheck();
    }
}
//ok
void MVA::typeCheck()
{
    // Todo
    if (id!=NULL)
    {
         Type *type1=id->getSymPtr()->getType();
        //首先判断是否为整型
        if(type1->isInt()!=1)
        {
            fprintf(stderr,"常量定义中 type %s 不匹配 in line xx",
            type1->toStr().c_str());
            exit(EXIT_FAILURE);
            return;
        }
        SymbolEntry *se=id->getSymPtr();
        std::string name=se->toStr();
        //然后判断是否重定义
       /* if(identifiers->search_inthis(name)!=nullptr)
        {
            fprintf(stderr,"常量%s 重定义",name.c_str());
            exit(EXIT_FAILURE);
            return;
        }*/
    }
    if(ass!=NULL)
    {
        ass->typeCheck();
    }
}
//ok
void VAs::typeCheck()
{
    // Todo
    va1->typeCheck();
    if(va2!=NULL)
    {
        va2->typeCheck();
    }
}
//ok
void MVAs::typeCheck()
{
    // Todo
    va1->typeCheck();
    if(va2!=NULL)
    {
        va2->typeCheck();
    }
}


//ok
void MULdecstmt::typeCheck()
{
    // Todo
    vas1->typeCheck();
    vas2->typeCheck();
}

//ok
void MULconstdecstmt::typeCheck()
{
    // Todo
    vas1->typeCheck();
    vas2->typeCheck();
}

//ok
void Whilestmt::typeCheck()
{
    // Todo
    //1判断cond的类型 必须要是INT的
    if(Cond->getSymPtr()->getType()->isInt()==1
    ||Cond->getSymPtr()->getType()->isConst()==1 )
    {
        Cond->getSymPtr()->setType(TypeSystem::boolType);
    }
    else{
        
        fprintf(stderr,"while语句条件类型不正确\n");
        exit(EXIT_FAILURE);
        return;
    }
    //对函数体进行类型检查
    stmt->typeCheck();
}

//ok
void Params::typeCheck()
{
    // Todo
   // fprintf(stderr,"para 1\n");
    if(exp1!=NULL)
    {
        exp1->typeCheck();
    }
   
    if(exp2!=NULL)
    {
        exp2->typeCheck();
    }
   //fprintf(stderr,"para 3\n");
}

//ok
void Param::typeCheck()
{
    // Todo
    // fprintf(stderr,"para 2\n");
     Type *type1=id->getSymPtr()->getType();
    //首先判断是否为整型
    if(type1->isInt()!=1)
    {
        fprintf(stderr,"参数定义中 type %s 不匹配 in line xx",
        type1->toStr().c_str());
        exit(EXIT_FAILURE);
        return;
    }
   
    //然后判断是否重定义
    /*if(identifiers->search_inthis(name)!=nullptr)
    {
        fprintf(stderr,"参数%s 重定义",name.c_str());
        exit(EXIT_FAILURE);
        return;
    }
    */
    if(expr1!=NULL)
    {    
        expr1->typeCheck();
        Type *type1 = expr1->getSymPtr()->getType();
        symbolEntry->setType(type1);   
    }
     
}

//ok
void Paramlist::typeCheck()
{
    // Todo
    exp1->typeCheck();
    if(exp2!=NULL)
    {
        exp2->typeCheck();
    }
}


void FuncCall::typeCheck()
{
    // Todo
    
    
    
    
}

//ok
void Emptystmt::typeCheck()
{
    // Todo
}


//ok
void DAssignStmt::typeCheck()
{
    // Todo
    id->typeCheck();
    expr->typeCheck();
    
    
    
    
}
//ok
void Funcname::typeCheck()
{
    // Todo
    //函数名称已经在语法分析中实现检查
}


void Idlist::typeCheck()
{
    // Todo
    
    expr1->typeCheck();
     expr2->typeCheck();
     
}
void VarDeclstmt::typeCheck()
{
    // Todo
    
    expr1->typeCheck();
}
void Decvar::typeCheck()
{
    // Todo
    
    id->typeCheck();
}



void PutInchars::typeCheck()
{
    // Todo
    //已经在语法分析中实现检查
}


void putsFunc::typeCheck()
{
    // Todo
    //已经在语法分析中实现检查
    expr1->typeCheck();
     expr1->typeCheck();
     if(expr3!=NULL)
        expr3->typeCheck();
}


//----------------------------------------output部分直接使用lab5












void BinaryExpr::output(int level)
{
    std::string op_str;
    switch(op)
    {
        case ADD:
            op_str = "add";
            break;
        case SUB:
            op_str = "sub";
            break;
        case AND:
            op_str = "and";
            break;
        case OR:
            op_str = "or";
            break;
        case LESS:
            op_str = "less";
            break;
         case MUL:
            op_str = "mul";
            break;
         case DIV:
            op_str = "div";
            break;
         case REM:
            op_str = "rem";
            break;
         case EQ:
			 op_str = "eq";
			 break;
		 case NEQ:
			 op_str = "neq";
			 break;
		 case GTR:
			 op_str = "gtr";
			 break;
		 case LEQ:
			 op_str = "leq";
			 break;
		 case GEQ:
			 op_str = "geq";
			 break;
            
            
            
    }
    fprintf(yyout, "%*cBinaryExpr\top: %s\n", level, ' ', op_str.c_str());
    expr1->output(level + 4);
    expr2->output(level + 4);
}
//单目运算的格式
void UnaryExp::output(int level)
{
    std::string op_str;
    switch(op)
    {
        case ADD:
            op_str = "add";
            break;
        case SUB:
            op_str = "sub";
            break;
        case NOT:
			op_str = "not";
			break;
    }
    fprintf(yyout, "%*cUnaryExp\top: %s\n", level, ' ', op_str.c_str());
    expr1->output(level + 4);
}




void Constant::output(int level)
{
    std::string type, value;
    type = symbolEntry->getType()->toStr();
    value = symbolEntry->toStr();
    fprintf(yyout, "%*cIntegerLiteral\tvalue: %s\ttype: %s\n", level, ' ',
            value.c_str(), type.c_str());
}

void Id::output(int level)
{
    std::string name, type;
    int scope;
    
    name = symbolEntry->toStr();
    type = symbolEntry->getType()->toStr();
    scope = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getScope();
    fprintf(yyout, "%*cId\tname: %s\tscope: %d\ttype: %s\n", level, ' ',
            name.c_str(), scope, type.c_str());
}

void ConstId::output(int level)
{
    std::string name, type;
    int scope;
    
    name = symbolEntry->toStr();
    type = symbolEntry->getType()->toStr();
    scope = dynamic_cast<IdentifierSymbolEntry*>(symbolEntry)->getScope();
    fprintf(yyout, "%*cConstId\tname: %s\tscope: %d\ttype: %s\n", level, ' ',
            name.c_str(), scope, type.c_str());
}


void ADDstmt::output(int level)
{
    fprintf(yyout, "%*cOpStmt\n", level, ' ');
    expr->output(level + 4);
}


void CompoundStmt::output(int level)
{
    fprintf(yyout, "%*cCompoundStmt\n", level, ' ');
    if(stmt!=NULL)
        stmt->output(level + 4);
}

void Emptystmt::output(int level)
{
    fprintf(yyout, "%*cEmptyStmt\n", level, ' ');
    //stmt->output(level + 4);
}


void SeqNode::output(int level)
{
    fprintf(yyout, "%*cSequence\n", level, ' ');
    stmt1->output(level + 4);
    if(stmt2!=NULL)
    {stmt2->output(level + 4);
    }
}

void ConstDeclstmt::output(int level)
{
    fprintf(yyout, "%*cConstDeclStmt\n", level, ' ');
    expr->output(level + 4);
    
}



void DeclStmt::output(int level)
{
    fprintf(yyout, "%*cDeclStmt\n", level, ' ');
    id->output(level + 4);
    if (dassignStmt!=NULL) 
        dassignStmt->output(level + 4);
}

void MULdecstmt::output(int level)
{
    fprintf(yyout, "%*cMulDeclStmt\n", level, ' ');
    vas1->output(level + 4);
    vas2->output(level + 4);
    
}

void MULconstdecstmt::output(int level)
{
    fprintf(yyout, "%*cMulconstDeclStmt\n", level, ' ');
    vas1->output(level + 4);
    vas2->output(level + 4);
    
}



void DAssignStmt::output(int level)
{
    
    
     fprintf(yyout, "%*cDecl and Assign\n", level, ' ');
    id->output(level + 4);
    expr->output(level+4);
    
    
    
    id->output(level + 4);
    
        
    expr->output(level + 4);
}

void VAs::output(int level)
{
    fprintf(yyout, "%*cVariables\n", level, ' ');
    
    if(va1!=NULL)
        va1->output(level+4);
    if(va2!=NULL)
        va2->output(level+4);
}

void VA::output(int level)
{
    fprintf(yyout, "%*cVariable\n", level, ' ');
    if(id!=NULL)
        id->output(level + 4);
    if(ass!=NULL)
        ass->output(level + 4);
    
}

void MVAs::output(int level)
{
    fprintf(yyout, "%*cVariables\n", level, ' ');
    
    if(va1!=NULL)
        va1->output(level+4);
    if(va2!=NULL)
        va2->output(level+4);
}

void MVA::output(int level)
{
    fprintf(yyout, "%*cVariable\n", level, ' ');
    if(id!=NULL)
        id->output(level + 4);
    if(ass!=NULL)
        ass->output(level + 4);
    
}









void IfStmt::output(int level)
{
    fprintf(yyout, "%*cIfStmt\n", level, ' ');
    cond->output(level + 4);
    thenStmt->output(level + 4);
}

void IfElseStmt::output(int level)
{
    fprintf(yyout, "%*cIfElseStmt\n", level, ' ');
    cond->output(level + 4);
    thenStmt->output(level + 4);
    elseStmt->output(level + 4);
}

void ReturnStmt::output(int level)
{
    fprintf(yyout, "%*cReturnStmt\n", level, ' ');
    
    if(retValue1!=NULL)
        retValue1->output(level + 4);
}

void Whilestmt::output(int level)
{
    fprintf(yyout, "%*cWhilestmt\n", level, ' ');
    Cond->output(level + 4);
    stmt->output(level + 4);
}
//更改输出
void AssignStmt::output(int level)
{
    fprintf(yyout, "%*cAssignStmt\n", level, ' ');
    
    if (lval!=NULL)
        lval->output(level + 4);
    
        
    expr->output(level + 4);
}

//更改输出
/*
void AssignExp::output(int level)
{
    fprintf(yyout, "%*cAssignStmt\n", level, ' ');
    
    
    lval->output(level + 4);
    
        
    expr->output(level + 4);
}
*/


void ConstDecAndAssStmt::output(int level)
{
    fprintf(yyout, "%*cConstDeclStmt\n", level, ' ');
    id->output(level + 4);
    
    
    
    fprintf(yyout, "%*cConstAssignStmt\n", level, ' ');
    
    
    id->output(level + 4);
    
        
    expr->output(level + 4);
}




void FunctionDef::output(int level)
{
    std::string name, type;
    //fprintf(stderr, "函数定义断点1 \n");
    name = se->toStr();
    type = se->getType()->toStr();
   // fprintf(stderr, "函数定义断点2\n");
    fprintf(yyout, "%*cFunctionDefine function name: %s, type: %s\n", level, ' ', 
     name.c_str(), type.c_str());
     if(params!=NULL)
        params->output(level+4);
    stmt->output(level + 4);
    // fprintf(stderr, "函数定义断点3 \n");
}

void Params::output(int level)
{
    
    fprintf(yyout, "%*cParams \n", level,' ' );
    if(exp1!=NULL)
        exp1->output(level + 4);
    if(exp2!=NULL)
        exp2->output(level + 4);
}

void Param::output(int level)
{
    
    fprintf(yyout, "%*cParam \n", level,' ' );
    id->output(level + 4);
    if(expr1!=NULL)
        expr1->output(level + 4);
}




void Paramlist::output(int level)
{
    
    fprintf(yyout, "%*cParamlist \n", level,' ' );
    exp1->output(level + 4);
    if(exp2!=NULL)
        exp2->output(level + 4);
}

void Funcname::output(int level)
{
    
    fprintf(yyout, "%*cFuncName \n", level,' ' );
    id->output(level + 4);
    
}
void FuncCallExp::output(int level)
{
    
    fprintf(yyout, "%*cFuncCallExp \n", level,' ' );
    id->output(level + 4);
    if(params!=NULL)
        params->output(level + 4);
}

void FuncCall::output(int level)
{
    
    fprintf(yyout, "%*cFuncCall \n", level,' ' );
    /*id->output(level + 4);
    if(params!=NULL)
        params->output(level + 4);*/
       expr->output(level+4);
}


void Idlist::output(int level)
{
    fprintf(yyout, "%*cIdlist \n", level,' ' );
    expr1->output(level+4);
    expr2->output(level+4);
}
void VarDeclstmt::output(int level)
{
    fprintf(yyout, "%*cVarDeclstmt \n", level,' ' );
    expr1->output(level+4);
    
}
void Decvar::output(int level)
{
    fprintf(yyout, "%*cDecvar \n", level,' ' );
    id->output(level+4);
    
}

void PutInchars::output(int level)
{
    std::string text;
    text = symbolEntry->toStr();
    fprintf(yyout, "%*c char*: %s\n", level, ' ',
            text.c_str());
}
void putsFunc::output(int level)
{
    fprintf(yyout, "%*cFunctUtilStmt\n", level, ' ');
    expr1->output(level + 4);
    expr2->output(level + 4);
    if (expr3!=NULL)
    {
        expr3->output(level+4);
    }
}

void Ast::output()
{
    fprintf(yyout, "program\n");
    if(root != nullptr)
        root->output(4);
}

